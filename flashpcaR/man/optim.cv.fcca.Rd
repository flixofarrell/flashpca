% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scca.R
\name{optim.cv.fcca}
\alias{optim.cv.fcca}
\title{Optimise FCCA via grid search and/or Bayesian optimisation.}
\usage{
optim.cv.fcca(
  X,
  Y,
  ndim = 1,
  nfolds = 5,
  folds = NULL,
  lambda1.grid = c(0, seq(1e-04, 0.002, length = 4)),
  lambda2.grid = c(0, seq(1e-04, 0.002, length = 4)),
  gamma1.grid = 10^(-2:0),
  gamma2.grid = 10^(-2:0),
  lambda1.bopt = c(0, 1),
  lambda2.bopt = c(0, 1),
  gamma1.bopt = 10^c(-3, 4),
  gamma2.bopt = 10^c(-3, 4),
  method = c("bopt", "grid"),
  parallel = FALSE,
  final.model = TRUE,
  final.model.cv = FALSE,
  final.model.reorder = FALSE,
  maxiter = 1000,
  svd.tol = 1e-12,
  verbose = FALSE
)
}
\arguments{
\item{X}{An n by p numeric matrix. Note: PLINK data is currently not supported.}

\item{Y}{An n by k numeric matrix.}

\item{ndim}{Integer. Positive number of canonical vectors to compute.}

\item{nfolds}{Integer. Number of cross-validation folds.}

\item{folds}{Integer. The fold identifiers. Overrides the `nfolds'
parameter.}

\item{lambda1.grid}{Numeric vector. Non-negative L1 penalty on canonical
vectors of X for use in the grid search.}

\item{lambda2.grid}{Numeric vector. Non-negative L1 penalty on canonical vectors of Y
for use in the grid search.}

\item{gamma1.grid}{Numeric vector. Non-negative L2 penalty on X for
use in the grid search.}

\item{gamma2.grid}{Numeric vector. Non-negative L2 penalty on Y for
use in the grid search.}

\item{lambda1.bopt}{Numeric vector. Non-negative L1 penalty on canonical
vectors of X for use in the Bayesian optimisation.}

\item{lambda2.bopt}{Numeric vector. Non-negative L1 penalty on canonical vectors of Y
for use in the Bayesian optimisation.}

\item{gamma1.bopt}{Numeric vector. Non-negative L2 penalty on X for
use in the Bayesian optimisation.}

\item{gamma2.bopt}{Numeric vector. Non-negative L2 penalty on Y for
use in the Bayesian optimisation.}

\item{method}{Character. Either "bapt" (Bayesian optimisation) or "grid"
(grid search).}

\item{final.model}{Logical. Whether to fit and return the final model trained on
all the data using the optimal hyperparameters.}

\item{final.model.cv}{Logical. Whether to fit a model in cross-validation 
using the optimal hyperparameters, and return it.}

\item{final.model.reorder}{Logical. Whether to reorder the canonical
coordinates based on the cross-validation correlations (in decreasing
magnitude).}

\item{maxiter}{Integer. Maximum number of iterations for FCCA fitting.}

\item{svd.tol}{Numeric. Tolerance under which to truncate singular values of X and Y.}

\item{verbose}{Logical.}

\item{parallal}{Logical. Whether to use parallelisation. Requires the use
of the \code{foreach} package.}
}
\value{
an \code{optim.cv.fcca} object with the following components:

\describe{
   \item{ndim:} Number of dimensions.
   \item{folds:} The vector of folds.
   \item{nfolds:} The number of folds.
   \item{grid.path:} The results for the grid search.
   \item{bopt:} The mlrMBO result (if using Bayesian optimisation).
   \item{bopt.path:} The Bayesian optimisation results (if using Bayesian
optimisation).
   \item{opt.param:} The optimal hyperparameters .
   \item{final.model:} An FCCA model trained on all the data using the
 optimal hyperparameters.
   \item{final.model.cv:} An FCCA model trained in cross-validation using
 the optimal hyperparameters.
   \item{final.model.cv.Px:} The canonical coordinates for X from
 the cross-validated FCCA model.
   \item{final.model.cv.Py:} The canonical coordinates for Y from
 the cross-validated FCCA model.
   \item{final.model.reordered:} Whether the canonical coordinates for the 
 final model were reordered by the cross-validated canonical
 correlations.
}
}
\description{
Optimise FCCA via grid search and/or Bayesian optimisation.
}
\examples{
#######################
## HapMap3 chr1 example
data(hm3.chr1)
X <- scale2(hm3.chr1$bed)
n <- nrow(X)
m <- ncol(X)
k <- 10
B <- matrix(rnorm(m * k), m, k)
Y <- X \%*\% B + rnorm(n * k)

r <- optim.cv.fcca(X, Y, ndim=1, nfolds=3,
   lambda1.grid=seq(1e-3, 1e-1, length=5),
   lambda2.grid=seq(1e-4, 0.5, length=3),
   gamma1.grid=10^c(-3, -1),
   gamma2.grid=10^c(-3, -1), method="grid",
   final.model.cv=TRUE)

# The optimal hyperparameters
r$opt.param

# The cross-validated canonical correlations
diag(cor(r$final.model.cv.Px, r$final.model.cv.Py))

}

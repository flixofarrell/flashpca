% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fcca.R
\name{optim.cv.fcca}
\alias{optim.cv.fcca}
\title{Optimise FCCA via grid search and/or Bayesian optimisation.}
\usage{
optim.cv.fcca(
  X,
  Y,
  ndim = 1,
  nfolds = 5,
  folds = NULL,
  lambda1_grid = c(0, seq(1e-04, 0.002, length = 4)),
  lambda2_grid = c(0, seq(1e-04, 0.002, length = 4)),
  gamma1_grid = 10^(-2:0),
  gamma2_grid = 10^(-2:0),
  lambda1_bopt = c(0, 1),
  lambda2_bopt = c(0, 1),
  gamma1_bopt = 10^c(-3, 4),
  gamma2_bopt = 10^c(-3, 4),
  method = c("bopt", "grid"),
  parallel = FALSE,
  final_model = TRUE,
  final_model_cv = FALSE,
  final_model_reorder = FALSE,
  check_sign = TRUE,
  maxiter = 1000,
  svd_tol = 1e-12,
  verbose = FALSE
)
}
\arguments{
\item{X}{An n by p numeric matrix. Note: PLINK data is currently not supported.}

\item{Y}{An n by k numeric matrix.}

\item{ndim}{Integer. Positive number of canonical vectors to compute.}

\item{nfolds}{Integer. Number of cross-validation folds.}

\item{folds}{Integer. The fold identifiers. Overrides the `nfolds'
parameter.}

\item{lambda1_grid}{Numeric vector. Non-negative L1 penalty on canonical
vectors of X for use in the grid search.}

\item{lambda2_grid}{Numeric vector. Non-negative L1 penalty on canonical vectors of Y
for use in the grid search.}

\item{gamma1_grid}{Numeric vector. Non-negative L2 penalty on X for
use in the grid search.}

\item{gamma2_grid}{Numeric vector. Non-negative L2 penalty on Y for
use in the grid search.}

\item{lambda1_bopt}{Numeric vector. Non-negative L1 penalty on canonical
vectors of X for use in the Bayesian optimisation.}

\item{lambda2_bopt}{Numeric vector. Non-negative L1 penalty on canonical vectors of Y
for use in the Bayesian optimisation.}

\item{gamma1_bopt}{Numeric vector. Non-negative L2 penalty on X for
use in the Bayesian optimisation.}

\item{gamma2_bopt}{Numeric vector. Non-negative L2 penalty on Y for
use in the Bayesian optimisation.}

\item{method}{Character. Either "bapt" (Bayesian optimisation) or "grid"
(grid search).}

\item{final_model}{Logical. Whether to fit and return the final model trained on
all the data using the optimal hyperparameters.}

\item{final_model_cv}{Logical. Whether to fit a model in cross-validation 
using the optimal hyperparameters, and return it.}

\item{final_model_reorder}{Logical. Whether to reorder the canonical
coordinates based on the cross-validation correlations (in decreasing
magnitude).}

\item{check_sign}{Logical. Whether to check and correct the sign
of the singular vectors to prevent sign flipping in cross-validation.}

\item{maxiter}{Integer. Maximum number of iterations for FCCA fitting.}

\item{svd_tol}{Numeric. Tolerance under which to truncate singular values of X and Y.}

\item{verbose}{Logical.}

\item{parallal}{Logical. Whether to use parallelisation. Requires the use
of the \code{foreach} package.}
}
\value{
an \code{optim.cv.fcca} object with the following components:
}
\description{
Optimise FCCA via grid search and/or Bayesian optimisation.
}
\details{
Performs optimisation of the FCCA hyperparmeters {lambda1, lambda2, gamma1,
gamma2}, initially via grid search and optionally further tuned
by Bayesian optimisation.

The objective function is the cross-validated average r^2 between the 
predictions for X and Y (averaged over all k dimensions).

\describe{
   \item{ndim:} Number of dimensions.
   \item{folds:} The vector of folds.
   \item{nfolds:} The number of folds.
   \item{grid_path:} The results for the grid search.
   \item{bopt:} The mlrMBO result (if using Bayesian optimisation).
   \item{bopt_path:} The Bayesian optimisation results (if using Bayesian
optimisation).
   \item{opt_param:} The optimal hyperparameters .
   \item{final_model:} An FCCA model trained on all the data using the
 optimal hyperparameters.
   \item{final_model_cv:} An FCCA model trained in cross-validation using
 the optimal hyperparameters.
   \item{final_model_cv_Px:} The canonical coordinates for X from
 the cross-validated FCCA model.
   \item{final_model_cv_Py:} The canonical coordinates for Y from
 the cross-validated FCCA model.
   \item{final_model_reordered:} Whether the canonical coordinates for the 
 final model were reordered by the cross-validated canonical
 correlations.
}
}
\examples{
#######################
## HapMap3 chr1 example
data(hm3.chr1)
X <- scale2(hm3.chr1$bed)
n <- nrow(X)
m <- ncol(X)
k <- 10
B <- matrix(rnorm(m * k), m, k)
Y <- X \%*\% B + rnorm(n * k)

r <- optim.cv.fcca(X, Y, ndim=1, nfolds=3,
   lambda1_grid=seq(1e-3, 1e-1, length=5),
   lambda2_grid=seq(1e-4, 0.5, length=3),
   gamma1_grid=10^c(-3, -1),
   gamma2_grid=10^c(-3, -1), method="grid",
   final_model.cv=TRUE)

# The optimal hyperparameters
r$opt_param

# The cross-validated canonical correlations
diag(cor(r$final_model_cv_Px, r$final_model_cv_Py))

}
